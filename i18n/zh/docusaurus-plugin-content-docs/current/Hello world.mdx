---
title: 你好，世界
sidebar_position: 4

---

import { IfcCard } from "@site/src/components/Card/InfoCard";
import { IfcAlert } from "@site/src/components/Alert/Alert";
import { Scene } from "@site/src/components/Scene/Scene";

## ＃＃介绍

⚡ 用IFC.js创建一个BIM应用程序是非常容易的。你可以<a href="https://github.com/IFCjs/hello-world/tree/main/examples/web-ifc-three/helloworld">在这里</a>找到指南的完整项目，<a href="https://ifcjs.github.io/hello-world/examples/web-ifc-three/helloworld/">在这里</a>找到部署的应用程序。你只需要安装<a href="https://nodejs.org/en/">Node.js</a>和任何IDE就可以按照下面的步骤操作。另外，如果你没有任何IFC文件可以跟随，你可以<a href="https://github.com/IFCjs/test-ifc-files">在这里</a>得到一些。

<IfcAlert>
  使用IFC.js需要有网络开发（HTML、CSS、JavaScript）和Three.js的基本知识。如果你以前没有使用Three.js的经验，你也许应该看看<a href="https://threejs.org/manual/">这里</a>。
</IfcAlert>

这个最小的教程将用Vanilla JavaScript完成，没有使用React、Vue、Angular、Svelte等框架。然而，同样的步骤可以适应并应用于任何这些用例。

## 设置项目

\###安装库

首先要做的是创建一个空文件夹，用<code>npm init</code>命令启动一个新的npm项目。这将生成一个<code>package.json</code>文件，其中包含一些数据，如项目名称、版本、命令和依赖性。此外，必须用npm安装以下依赖项。

```bash
    //Install IFC.js
    npm i web-ifc-three

    // Install Three.js
    npm i three

    // Install a bundler: we will use rollup.js for this guide
    npm i rollup --save-dev
    npm i @rollup/plugin-node-resolve --save-dev
```

📝 下一步是创建一个名为<code>index.html</code>的HTML文件作为应用程序的主文件。该HTML将有。

*   一个<strong>画布元素</strong>，用于渲染Three.js场景。
*   一个<strong>输入元素</strong>，它将从我们的计算机上打开IFC文件到应用程序。
*   一个引用名为<code>bundle.js</code>的文件的<strong>脚本</strong>，这是我们将用rollup制作的应用程序的捆绑包。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <title>Document</title>
  </head>
  <body>
    <input type="file" name="load" id="file-input" />
    <canvas id="three-canvas"></canvas>
    <script src="bundle.js"></script>
  </body>
</html>
```

\###添加样式

🎨 以下CSS文件将使画布成为全屏。

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  overflow: hidden;
}

#three-canvas {
  position: fixed;
  top: 0;
  left: 0;
  outline: none;
}

#file-input {
  z-index: 1;
  position: absolute;
}
```

### 捆绑式

接下来，我们将创建rollup配置文件。这个文件必须被称为<code>rollup.config.js</code>，并包括对我们之前安装的插件的引用。

<IfcCard icon="🧻" title="轧制？">
  Rollup是一个非常流行的捆绑库。例如，它是Three.js使用的捆绑器。看看<a href="https://rollupjs.org/guide/en/">Rollup的文档</a>，了解更多。
</IfcCard>

```js
import resolve from "@rollup/plugin-node-resolve";

export default {
  input: "src/app.js",
  output: [
    {
      format: "esm",
      file: "src/bundle.js",
    },
  ],
  plugins: [resolve()],
};
```

🎯 另外，<code>package.json</code>文件需要修改，以包含控制rollup的命令，很容易。在每个命令中，你必须指定你的rollup配置文件的相对路径。如果我们正确地安装了一切，我们应该在这个文件中看到相同的依赖关系（库的版本可能不同）。

*   <code>npm run build</code>将捆绑项目，并在项目的根目录下创建一个名为<code>bundle.js</code>的文件。

*   <code>npm run watch</code>将激活<code>观察模式</code>，在我们每次对代码进行修改并保存时自动更新该文件。

```json
{
  "name": "example",
  "version": "1.0.0",
  "description": "-",
  "main": "app.js",
  "scripts": {
    "build": "rollup -c ./rollup.config.js",
    "watch": "rollup -w -c ./rollup.config.js"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@rollup/plugin-node-resolve": "^11.2.1",
    "rollup": "^2.45.2"
  },
  "dependencies": {
    "three": "^0.128.0",
    "web-ifc-three": "0.0.102"
  }
}
```

### WebAssembly

📁 接下来要做的是把<code>web-ifc.wasm</code>和<code>web-ifc-mt.wasm</code>文件复制到你项目中的一个目录。它可以在<code>node/modules/web-ifc</code>（如果你只使用Three的IFCLoader，可以在<code>node/modules/three/examples/jsm\loaders/ifc</code>）中找到。我们可以把它们复制到我们想要的地方；在这个例子中，它们将被复制到项目根目录下一个叫wasm的文件夹中。

这些文件是必要的，因为它们包含了<a href="https://github.com/IFCjs/web-ifc">web-ifc</a>的编译C++逻辑，它是以本地速度读写IFC文件的解析核心。

<IfcAlert>这些文件必须在你的应用程序中静态地提供。如果你使用的是React、Angular、Vue或Svelte等框架或库，这可能需要进行不同的调整。</IfcAlert>

## 设置一个3D场景

最后，我们要创建一个JavaScript文件，为我们的应用程序编写代码。这个文件可以位于任何地方，有任何名字，但你必须在<code>rollup.config.js</code>中反映这一点。

🧱 我们将使用Three.js创建一个基本的3D场景。

```js
import { AmbientLight, AxesHelper, DirectionalLight, GridHelper, PerspectiveCamera, Scene, WebGLRenderer } from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

//Creates the Three.js scene
const scene = new Scene();

//Object to store the size of the viewport
const size = {
  width: window.innerWidth,
  height: window.innerHeight,
};

//Creates the camera (point of view of the user)
const aspect = size.width / size.height;
const camera = new PerspectiveCamera(75, aspect);
camera.position.z = 15;
camera.position.y = 13;
camera.position.x = 8;

//Creates the lights of the scene
const lightColor = 0xffffff;

const ambientLight = new AmbientLight(lightColor, 0.5);
scene.add(ambientLight);

const directionalLight = new DirectionalLight(lightColor, 1);
directionalLight.position.set(0, 10, 0);
directionalLight.target.position.set(-5, 0, 0);
scene.add(directionalLight);
scene.add(directionalLight.target);

//Sets up the renderer, fetching the canvas of the HTML
const threeCanvas = document.getElementById("three-canvas");
const renderer = new WebGLRenderer({
  canvas: threeCanvas,
  alpha: true,
});

renderer.setSize(size.width, size.height);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

//Creates grids and axes in the scene
const grid = new GridHelper(50, 30);
scene.add(grid);

const axes = new AxesHelper();
axes.material.depthTest = false;
axes.renderOrder = 1;
scene.add(axes);

//Creates the orbit controls (to navigate the scene)
const controls = new OrbitControls(camera, threeCanvas);
controls.enableDamping = true;
controls.target.set(-2, 0, 0);

//Animation loop
const animate = () => {
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
};

animate();

//Adjust the viewport to the size of the browser
window.addEventListener("resize", () => {
  size.width = window.innerWidth;
  size.height = window.innerHeight;
  camera.aspect = size.width / size.height;
  camera.updateProjectionMatrix();
  renderer.setSize(size.width, size.height);
});
```

🌏 要在本地运行应用程序，我们将需要一个本地服务器。如果你使用VS Code作为IDE，一个选择是安装<a href="https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer">Live Server扩展</a>，它允许我们打开谷歌浏览器的一个实例，运行我们的网络应用程序，并实时查看我们对代码的修改。

\##加载IFC文件

\###加载用户的模型

🏠最后，我们将使用IFC.js加载IFC文件。这可以通过实例化加载器来完成，并为用户向HTML输入元素上传IFC文件时创建一个事件。

```js
import { IFCLoader } from "web-ifc-three/IFCLoader";

// Sets up the IFC loading
const ifcLoader = new IFCLoader();

const input = document.getElementById("file-input");
input.addEventListener(
  "change",
  (changed) => {
    const file = changed.target.files[0];
    var ifcURL = URL.createObjectURL(file);
    ifcLoader.load(ifcURL, (ifcModel) => scene.add(ifcModel));
  },
  false
);
```

🎣请记住，如果你没有把wasm文件保存在项目的服务文件根目录下，你需要用<code>setWasmPath</code>指定它的位置。例如，如果我们将它们保存在一个叫做<code>wasm</code>的文件夹中，该文件夹包含在项目根部一个叫做<code>static</code>的文件夹中，我们将做如下操作。

```js
ifcLoader.ifcManager.setWasmPath("static/wasm/");
```

<Scene link={"https://ifcjs.github.io/hello-world/examples/web-ifc-three/helloworld/"} />

如果你所做的一切都正确，你应该能够在你的本地服务器中看到与<a href="https://ifcjs.github.io/hello-world/examples/web-ifc-three/helloworld/">此</a>类似的东西。从这里开始，可能性是无穷的。

\###加载我们的模型

🤔在上一点中我们看到了如何直接加载BIM模型，这很好。如果我们想显示我们的BIM模型而不是让用户上传他们的模型呢？这很简单。一般来说，有两种可能性。

*   把IFC放在你想显示它的同一个应用程序中。
*   不得不从外部存储服务中获取。

    🎩在第一种情况下，只要引用IFC文件的URL即可。就是说，它在应用程序中的相对路径。例如，如果IFC在项目根部的 "models "文件夹中，我们可以在启动应用程序时加载该IFC，方法如下。

```js
ifcLoader.load("models/Example_model.ifc", (ifcModel) => scene.add(ifcModel));
```

<IfcAlert>从远程存储服务中获取文件的方法因使用的服务而异。然而，逻辑是相同的：获取信息，创建一个URL并将其作为参数传递给IFCLoader。</IfcAlert>

<Scene link={"https://ifcjs.github.io/hello-world/examples/web-ifc-three/introduction/"} />

## 结论

祝贺你！你刚刚创建了你的第一个IFC浏览器。你刚刚创建了你的第一个IFC浏览器。在接下来的几页文档中，你可以了解到IFC.js还能做什么。

<IfcCard icon="🔥" title="我还能用IFC.js做什么？">
  这仅仅是个开始。你可以看看<a href="https://github.com/IFCjs/web-ifc-viewer">web-ifc-viewer</a>，它包括选择对象、改变几何体外观、剖面图和更多的工具。你可以<a href="https://ifcjs.github.io/web-ifc-viewer/example/index">在这里</a>试试。
</IfcCard>
