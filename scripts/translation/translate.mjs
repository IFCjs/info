import glob from "glob";
import { Translator } from "deepl-node";
import p from "path";
import { config } from "./config.mjs";
import { TranslationMemory } from "./memory.mjs";
import { CWD, getFile, setFile } from "./utils.mjs";

const DEEPL_AUTH_KEY = process.env.DEEPL_AUTH_KEY;

async function main() {
  const memory = new TranslationMemory({
    cwd: CWD,
    storage: "./scripts/translation/memory.json",
  });
  const deepl = new Translator(DEEPL_AUTH_KEY);

  const sourceDir = config.translations.source.replace(
    "%language%",
    config.sourceLanguage
  );
  const sourcePattern = sourceDir.concat("/**/*.json");
  const sourcePaths = glob.sync(sourcePattern, {
    root: CWD,
  });

  for (const language of config.outputLanguages) {
    for (const sourcePath of sourcePaths) {
      const outputDir = config.translations.source.replace(
        "%language%",
        language
      );
      const outputPath = sourcePath.replace(
        toOsPath(sourceDir),
        toOsPath(outputDir)
      );

      const { value } = getFile(sourcePath);

      const parsedValue = JSON.parse(value);
      let strings;

      const isTranslationArray = Array.isArray(parsedValue);

      if (isTranslationArray) {
        strings = parsedValue;
      } else {
        strings = getTranslationStrings(parsedValue);
      }

      let translatedStrings = await translate(
        strings,
        config.sourceLanguage,
        language,
        memory,
        deepl
      );

      if (!isTranslationArray) {
        translatedStrings = setTranslationObject(translatedStrings);
      }

      setFile({
        path: outputPath,
        value: JSON.stringify(translatedStrings),
      });
    }
  }
}

main();

/**
 * Replace path separator with current OS path separator.
 *
 * @param { string } path
 * @returns { string }
 */
function toOsPath(path) {
  return path.includes("/")
    ? p.sep === "/"
      ? path
      : path.split("/").join(p.sep)
    : p.sep === "\\"
    ? path
    : path.split("\\").join(p.sep);
}

/**
 * Get an array of strings from translation object generated by
 * `docusaurus write-trasnlations` command.
 *
 * @param { { [Key: string]: { message: string; description: string } } } object
 * @returns { string[] }
 */
function getTranslationStrings(object) {
  const strings = [];

  for (const key of object) {
    strings.push(object[key].message);
  }

  return strings;
}

/**
 * Set translated string to its corresponding key in
 * docusuaurus generated translation object.
 *
 * @param { { [Key: string]: { message: string; description: string } } } object
 * @param { string[] } strings
 */
function setTranslationObject(object, strings) {
  let index = 0;

  for (const key in object) {
    object[key].message = strings[index];
    index++;
  }
}

/**
 * Translate strings with the combination of
 * translation memory and Deepl.
 *
 * @param { string[] } strings
 * @param { string } sourceLanguage
 * @param { string } outputLanguage
 * @param { import("./memory.mjs").TranslationMemory } memory
 * @param { import("deepl-node").Translator } deepl
 * @returns { Promise<string[]> }
 */
export async function translate(
  strings,
  sourceLanguage,
  outputLanguage,
  memory,
  deepl
) {
  /** @type { string[] } */
  let buffer = [];
  /** @type { number[] } */
  let bufferIndexes = [];
  /** @type { string[] } */
  const translatedStrings = [];

  for (let i = 0; i < strings.length; i++) {
    const string = strings[i];
    const fromMemory = memory.get(string, outputLanguage);

    if (fromMemory) {
      translatedStrings.push(fromMemory);
      continue;
    }

    buffer.push(string);
    bufferIndexes.push(i);
    translatedStrings.push("");
    if (buffer.length < 5 && i !== strings.length) continue;

    const fromDeepl = await deepl.translateText(
      buffer,
      sourceLanguage,
      outputLanguage,
      {
        tagHandling: "html",
        ignoreTags: ["canvas"],
      }
    );

    for (let i = 0; i < buffer.length; i++) {
      const index = bufferIndexes[i];
      const string = fromDeepl[i];

      memory.set(string, outputLanguage);
      translatedStrings[index] = string;
    }

    buffer = [];
    bufferIndexes = [];
  }
}
